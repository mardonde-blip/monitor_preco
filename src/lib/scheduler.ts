import cron, { ScheduledTask } from 'node-cron';
import { PriceScraper } from './scraper';
import { TelegramNotifier } from './telegram';
import { LocalStorage } from './storage';
import { Product, NotificationSettings } from '../types';
import { getDatabase } from './database-adapter';
import { sendEmail, emailTemplates } from './email';
// import { ExaProductSearch } from './exa-search'; // Temporariamente desabilitado

export class PriceMonitorScheduler {
  private scraper: PriceScraper;
  private telegramNotifier: TelegramNotifier;
  // private exaSearch: ExaProductSearch; // Temporariamente desabilitado
  private isRunning: boolean = false;
  private cronJob: ScheduledTask | null = null;
  private lastRun: string | null = null;

  constructor() {
    this.scraper = new PriceScraper();
    this.telegramNotifier = new TelegramNotifier();
    // this.exaSearch = new ExaProductSearch(); // Temporariamente desabilitado
  }

  /**
   * Inicia o agendamento de monitoramento
   */
  async startScheduler(intervalMinutes: number = 60): Promise<void> {
    if (this.isRunning) {
      console.log('Scheduler j치 est치 rodando');
      return;
    }

    // Converte minutos para formato cron (a cada X minutos)
    // Para intervalos maiores que 59 minutos, usa uma abordagem diferente
    let cronExpression: string;
    
    if (intervalMinutes <= 59) {
      cronExpression = `*/${intervalMinutes} * * * *`;
    } else {
      // Para intervalos de horas, converte para horas
      const hours = Math.floor(intervalMinutes / 60);
      cronExpression = `0 */${hours} * * *`;
    }
    
    this.cronJob = cron.schedule(cronExpression, async () => {
      await this.runMonitoringCycle();
    }, {
      timezone: 'America/Sao_Paulo'
    });

    this.cronJob.start();
    this.isRunning = true;
    
    console.log(`Scheduler iniciado - verificando pre칞os a cada ${intervalMinutes} minutos`);
    
    // Executa uma verifica칞칚o inicial
    await this.runMonitoringCycle();
  }

  /**
   * Para o agendamento
   */
  stopScheduler(): void {
    if (this.cronJob) {
      this.cronJob.stop();
      this.cronJob = null;
    }
    this.isRunning = false;
    console.log('Scheduler parado');
  }

  /**
   * Executa um ciclo completo de monitoramento
   */
  private async runMonitoringCycle(): Promise<void> {
    try {
      this.lastRun = new Date().toISOString();
      console.log('Iniciando ciclo de monitoramento...', this.lastRun);
      
      const db = await getDatabase();
      const productsData = await db.getAllProducts();
      const products = productsData as Array<{id: number; name: string; url: string; target_price: number; current_price?: number; store: string}>;
      const notificationSettings = await this.getNotificationSettings();
      
      if (!products.length) {
        console.log('Nenhum produto para monitorar');
        return;
      }

      if (!notificationSettings.enabled) {
        console.log('Notifica칞칫es desabilitadas');
        return;
      }

      // Scraper n칚o precisa de inicializa칞칚o expl칤cita
      
      const results = await Promise.allSettled(
        products.map(product => this.checkProductPrice({
          id: product.id.toString(),
          name: product.name,
          url: product.url,
          initialPrice: product.target_price,
          currentPrice: product.current_price,
          targetPrice: product.target_price,
          selector: 'auto',
          addedAt: new Date().toISOString(),
          target_price: product.target_price,
          current_price: product.current_price,
          created_at: new Date().toISOString(),
          user_id: 1
        } as Product & {target_price: number; current_price?: number; created_at: string; user_id: number}))
      );
      
      await this.scraper.close();
      
      const successful = results.filter(r => r.status === 'fulfilled').length;
      const failed = results.filter(r => r.status === 'rejected').length;
      
      console.log(`Ciclo conclu칤do: ${successful} sucessos, ${failed} falhas`);
      
    } catch (error) {
      console.error('Erro no ciclo de monitoramento:', error);
    }
  }

  /**
   * Verifica o pre칞o de um produto espec칤fico
   */
  private async checkProductPrice(
    product: Product
  ): Promise<void> {
    try {
      // Use automatic detection for Product
      const scrapingResult = await this.scraper.scrapePriceAuto(product.url);
      
      if (!scrapingResult.success || scrapingResult.price === null) {
        console.error(`Falha ao obter pre칞o para ${product.name}:`, scrapingResult.error);
        
        // Mesmo com falha no scraping, verifica se o produto j치 est치 com pre칞o abaixo do alvo
        const targetPrice = product.targetPrice;
        const currentPrice = product.currentPrice;
        
        if (currentPrice !== null && currentPrice !== undefined && targetPrice !== undefined && currentPrice <= targetPrice) {
          console.log(`游꿢 PRODUTO J츼 COM PRE칂O BAIXO: ${product.name} - R$ ${currentPrice.toFixed(2)} <= R$ ${Number(targetPrice).toFixed(2)}`);
          await this.sendPriceAlert(product);
        }
        
        return;
      }
      
      const newPrice = scrapingResult.price;
      const previousPrice = product.currentPrice;
      
      // Atualiza o pre칞o atual do produto no banco de dados
      await this.updateProductViaAPI({
        id: product.id.toString(),
        name: product.name,
        url: product.url,
        initialPrice: product.targetPrice,
        currentPrice: newPrice,
        targetPrice: product.targetPrice,
        selector: '',
        addedAt: product.addedAt,
        userId: 1
      } as Product);
      
      // Verifica se o pre칞o atual est치 abaixo do pre칞o alvo (envia notifica칞칚o quando pre칞o alvo > pre칞o atual)
      const targetPrice = product.targetPrice;
      const priceDropped = newPrice !== null && newPrice !== undefined && targetPrice !== null && targetPrice !== undefined && targetPrice > newPrice;
      
      if (priceDropped) {
        await this.sendPriceAlert(product);
      }
      
      console.log(`${product.name}: R$ ${newPrice?.toFixed(2) || 'N/A'} (alvo: R$ ${Number(targetPrice || 0).toFixed(2)}, anterior: R$ ${previousPrice !== null && previousPrice !== undefined ? previousPrice.toFixed(2) : 'N/A'})`);
      
      if (priceDropped) {
        console.log(`游꿢 ALERTA: Pre칞o de ${product.name} baixou para R$ ${newPrice?.toFixed(2) || 'N/A'}!`);
      }
      
    } catch (error) {
      console.error(`Erro ao verificar pre칞o de ${product.name}:`, error);
    }
  }

  /**
   * Envia alerta de pre칞o via Telegram e Email
   */
  private async sendPriceAlert(product: Product): Promise<void> {
    try {
      const notificationSettings = await this.getNotificationSettings();
      
      if (!notificationSettings.enabled) {
        return;
      }
      
      // Usa o pre칞o anterior para calcular o desconto corretamente
      let previousPrice = product.currentPrice;
      
      // Se n칚o h치 pre칞o anterior, usa o pre칞o alvo como refer칡ncia
      if (!previousPrice) {
        previousPrice = product.targetPrice;
      }
      
      // Evita desconto 0.0% quando pre칞os s칚o iguais
      if (previousPrice === product.currentPrice) {
        // Se todos os pre칞os s칚o iguais, usa um valor ligeiramente maior para mostrar "economia"
        previousPrice = product.currentPrice! * 1.01; // 1% maior
      }
      
      // Enviar notifica칞칚o via Telegram
      try {
        this.telegramNotifier.init({
          botToken: notificationSettings.telegram.botToken,
          chatId: notificationSettings.telegram.chatId
        });
        
        await this.telegramNotifier.sendPriceAlert(
          {
            id: product.id.toString(),
            name: product.name,
            url: product.url,
            initialPrice: product.targetPrice,
            currentPrice: product.currentPrice,
            targetPrice: product.targetPrice,
            selector: '',
            addedAt: product.addedAt
          } as Product,
          previousPrice || 0,
          product.currentPrice || 0
        );
        
        console.log(`Alerta Telegram enviado para ${product.name}`);
      } catch (telegramError) {
        console.error('Erro ao enviar alerta via Telegram:', telegramError);
      }
      
      // Enviar notifica칞칚o via Email
      try {
        await this.sendEmailAlert(product, previousPrice || 0, product.currentPrice || 0);
        console.log(`Alerta Email enviado para ${product.name}`);
      } catch (emailError) {
        console.error('Erro ao enviar alerta via Email:', emailError);
      }
      
      console.log(`Alertas enviados para ${product.name} (desconto calculado com base em R$ ${previousPrice !== null && previousPrice !== undefined ? previousPrice.toFixed(2) : 'N/A'} -> R$ ${Number(product.currentPrice || 0).toFixed(2)})`);
      
    } catch (error) {
      console.error('Erro ao enviar alerta:', error);
    }
  }
  
  /**
   * Envia alerta de pre칞o por email
   */
  private async sendEmailAlert(product: Product, oldPrice: number, newPrice: number): Promise<void> {
    try {
      // Buscar usu치rios que monitoram este produto
      const users = await this.getUsersForProduct(product.id.toString());
      
      for (const user of users) {
        if (user.email) {
          const emailContent = emailTemplates.priceAlertEmail(
            user.name || 'Usu치rio',
            product.name,
            oldPrice,
            newPrice,
            product.url
          );
          
          await sendEmail({
            to: user.email,
            subject: emailContent.subject,
            html: emailContent.html
          });
          
          console.log(`Email de alerta enviado para ${user.email}`);
        }
      }
    } catch (error) {
      console.error('Erro ao enviar email de alerta:', error);
    }
  }

  /**
   * Verifica se o scheduler est치 rodando
   */
  isSchedulerRunning(): boolean {
    return this.isRunning;
  }

  /**
   * Executa uma verifica칞칚o manual de todos os produtos
   */
  async runManualCheck(): Promise<void> {
    console.log('Executando verifica칞칚o manual com scraper tradicional...');
    
    try {
      const db = await getDatabase();
      const productsData = await db.getAllProducts();
      const products = productsData as Array<{id: number; name: string; url: string; target_price: number; current_price?: number; store: string}>;
      const notificationSettings = await this.getNotificationSettings();
      
      if (!products.length) {
        console.log('Nenhum produto para monitorar');
        return;
      }

      if (!notificationSettings.enabled) {
        console.log('Notifica칞칫es desabilitadas');
        return;
      }

      // Executa verifica칞칚o manual usando scraper tradicional para cada produto
      const results = await Promise.allSettled(
        products.map(product => this.checkProductPrice({
          id: product.id.toString(),
          name: product.name,
          url: product.url,
          initialPrice: product.target_price,
          currentPrice: product.current_price,
          targetPrice: product.target_price,
          selector: 'auto',
          addedAt: new Date().toISOString(),
          target_price: product.target_price,
          current_price: product.current_price,
          created_at: new Date().toISOString(),
          user_id: 1
        } as Product & {target_price: number; current_price?: number; created_at: string; user_id: number}))
      );
      
      await this.scraper.close();
      
      const successful = results.filter(r => r.status === 'fulfilled').length;
      const failed = results.filter(r => r.status === 'rejected').length;
      
      console.log(`Verifica칞칚o manual conclu칤da: ${successful} sucessos, ${failed} falhas`);
      
    } catch (error) {
      console.error('Erro na verifica칞칚o manual:', error);
    }
  }

  /**
   * Retorna a data/hora da 칰ltima execu칞칚o
   */
  getLastRun(): string | null {
    return this.lastRun;
  }

  /**
   * Obt칠m configura칞칫es de notifica칞칚o via API
   */
  private async getNotificationSettings(): Promise<NotificationSettings> {
    try {
      const response = await fetch('http://localhost:3000/api/settings');
      if (response.ok) {
        return await response.json();
      }
    } catch (error) {
      console.error('Erro ao obter configura칞칫es via API:', error);
    }
    
    // Fallback para localStorage se API falhar
    return LocalStorage.getSettings();
  }

  /**
   * Atualiza um produto diretamente no banco de dados
   */
  private async updateProductViaAPI(product: Product): Promise<void> {
    try {
      // Buscar o produto original para obter o user_id
      const db = await getDatabase();
      const originalProduct = await db.getProductById(parseInt(product.id));
      if (!originalProduct) {
        throw new Error(`Produto com ID ${product.id} n칚o encontrado`);
      }
      
      // Usar diretamente o banco de dados em vez da API para evitar problemas de autentica칞칚o
      const dbProduct = originalProduct as { user_id: number; store: string };
      await db.updateProduct(parseInt(product.id), dbProduct.user_id, {
        name: product.name,
        url: product.url,
        target_price: product.targetPrice || 0,
        current_price: product.currentPrice,
        store: dbProduct.store
      });
    } catch (error) {
      console.error('Erro ao atualizar produto no banco:', error);
      // Fallback para localStorage se banco falhar
      LocalStorage.updateProduct(product.id, product);
    }
  }
  
  /**
   * Verifica o pre칞o de um produto espec칤fico usando MCP de busca
   * TEMPORARIAMENTE DESABILITADO - Usando apenas scraper tradicional
   */
  /*
  private async checkProductPriceWithMCP(
    product: Product
  ): Promise<void> {
    try {
      console.log(`Buscando pre칞o atual para ${product.name} usando MCP...`);
      
      // Usa o MCP de busca para encontrar o pre칞o atual do produto
      const searchResults = await this.exaSearch.searchProducts(product.name, {
        maxResults: 5,
        includeText: true,
        includeHighlights: true
      });
      
      if (!searchResults.length) {
        console.error(`Nenhum resultado encontrado para ${product.name} via MCP`);
        return;
      }
      
      // Pega o primeiro resultado (melhor score) e tenta extrair o pre칞o
      const bestResult = searchResults[0];
      console.log(`Melhor resultado MCP para ${product.name}: ${bestResult.name} - Score: ${bestResult.score}`);
      
      // Se o resultado tem pre칞o estimado, usa ele
      let currentPrice = bestResult.estimatedPrice;
      
      // Se n칚o tem pre칞o estimado, tenta fazer scraping da URL encontrada
      if (!currentPrice && bestResult.url) {
        console.log(`Fazendo scraping da URL encontrada via MCP: ${bestResult.url}`);
        const scrapingResult = await this.scraper.scrapePriceAuto(bestResult.url);
        if (scrapingResult.success && scrapingResult.price !== null) {
          currentPrice = scrapingResult.price;
        }
      }
      
      if (!currentPrice) {
        console.error(`N칚o foi poss칤vel obter pre칞o para ${product.name} via MCP`);
        return;
      }
      
      console.log(`Pre칞o atual encontrado via MCP para ${product.name}: R$ ${currentPrice.toFixed(2)}`);
      
      // Atualiza o pre칞o atual do produto no banco de dados
      await this.updateProductViaAPI({
        id: product.id.toString(),
        name: product.name,
        url: product.url,
        initialPrice: product.targetPrice,
        currentPrice: currentPrice,
        targetPrice: product.targetPrice,
        selector: '',
        addedAt: product.addedAt,
        userId: 1
      } as Product);
      
      // Verifica se o pre칞o atual est치 abaixo do pre칞o alvo
      const targetPrice = product.targetPrice;
      const priceDropped = currentPrice !== null && currentPrice !== undefined && targetPrice !== null && targetPrice !== undefined && targetPrice > currentPrice;
      
      console.log(`${product.name}: R$ ${currentPrice.toFixed(2)} (alvo: R$ ${Number(targetPrice || 0).toFixed(2)})`);
      
      if (priceDropped) {
        console.log(`游꿢 ALERTA MCP: Pre칞o de ${product.name} est치 abaixo do alvo! R$ ${currentPrice.toFixed(2)} < R$ ${Number(targetPrice).toFixed(2)}`);
        
        // Cria um produto atualizado com o novo pre칞o para enviar o alerta
        const updatedProduct = {
          ...product,
          currentPrice: currentPrice
        };
        
        await this.sendPriceAlert(updatedProduct);
      }
      
    } catch (error) {
      console.error(`Erro ao verificar pre칞o de ${product.name} via MCP:`, error);
    }
  }
  */
   
   /**
    * Busca usu치rios que monitoram um produto espec칤fico
    */
   private async getUsersForProduct(productId: string): Promise<Array<{id: number, name: string, email: string}>> {
     try {
      const response = await fetch(`http://localhost:3000/api/users?productId=${productId}`);
      if (response.ok) {
        return await response.json();
      }
    } catch (error) {
      console.error('Erro ao buscar usu치rios via API:', error);
    }
    
    // Fallback: retorna lista vazia se n칚o conseguir buscar usu치rios
    // Em um sistema real, isso deveria buscar do banco de dados
    return [];
  }
}

// Inst칙ncia singleton para uso global
export const priceMonitorScheduler = new PriceMonitorScheduler();